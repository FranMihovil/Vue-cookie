import type { ReplayRecordingData } from '@sentry/types';
import type { AddEventResult, EventBuffer, RecordingEvent } from './types';
interface CreateEventBufferParams {
    useCompression: boolean;
}
/**
 * Create an event buffer for replays.
 */
export declare function createEventBuffer({ useCompression }: CreateEventBufferParams): EventBuffer;
/**
 * This proxy will try to use the compression worker, and fall back to use the simple buffer if an error occurs there.
 * This can happen e.g. if the worker cannot be loaded.
 * Exported only for testing.
 */
export declare class EventBufferProxy implements EventBuffer {
    private _fallback;
    private _compression;
    private _used;
    constructor(worker: Worker);
    /** @inheritDoc */
    get pendingLength(): number;
    /** @inheritDoc */
    get pendingEvents(): RecordingEvent[];
    /** @inheritDoc */
    destroy(): void;
    /**
     * Add an event to the event buffer.
     *
     * Returns true if event was successfully added.
     */
    addEvent(event: RecordingEvent, isCheckout?: boolean): Promise<AddEventResult>;
    /** @inheritDoc */
    finish(): Promise<ReplayRecordingData>;
    /** Ensure the worker has loaded. */
    private _ensureWorkerIsLoaded;
}
/**
 * Event buffer that uses a web worker to compress events.
 * Exported only for testing.
 */
export declare class EventBufferCompressionWorker implements EventBuffer {
    /**
     * Keeps track of the list of events since the last flush that have not been compressed.
     * For example, page is reloaded and a flush attempt is made, but
     * `finish()` (and thus the flush), does not complete.
     */
    _pendingEvents: RecordingEvent[];
    private _worker;
    private _eventBufferItemLength;
    private _id;
    constructor(worker: Worker);
    /**
     * The number of raw events that are buffered. This may not be the same as
     * the number of events that have been compresed in the worker because
     * `addEvent` is async.
     */
    get pendingLength(): number;
    /**
     * Returns a list of the raw recording events that are being compressed.
     */
    get pendingEvents(): RecordingEvent[];
    /**
     * Ensure the worker is ready (or not).
     * This will either resolve when the worker is ready, or reject if an error occured.
     */
    ensureReady(): Promise<void>;
    /**
     * Destroy the event buffer.
     */
    destroy(): void;
    /**
     * Add an event to the event buffer.
     *
     * Returns true if event was successfuly received and processed by worker.
     */
    addEvent(event: RecordingEvent, isCheckout?: boolean): Promise<AddEventResult>;
    /**
     * Finish the event buffer and return the compressed data.
     */
    finish(): Promise<Uint8Array>;
    /**
     * Post message to worker and wait for response before resolving promise.
     */
    private _postMessage;
    /**
     * Send the event to the worker.
     */
    private _sendEventToWorker;
    /**
     * Finish the request and return the compressed data from the worker.
     */
    private _finishRequest;
    /** Get the current ID and increment it for the next call. */
    private _getAndIncrementId;
}
export {};
//# sourceMappingURL=eventBuffer.d.ts.map